<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.544">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>The Art of Scientific computation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.js"></script>
<link href="site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.css" rel="stylesheet">
<script src="site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script>
MathJax = {
  loader: {
    load: ['[tex]/boldsymbol']
  },
  tex: {
    tags: "all",
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEscapes: true,
    processEnvironments: true,
    packages: {
      '[+]': ['boldsymbol']
    }
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>


<meta name="citation_title" content="The Art of Scientific computation">
<meta name="citation_author" content="(James) Reuben Bender">
<meta name="citation_language" content="en">
<meta name="citation_reference" content="citation_title=Self-organized criticality: An explanation of the 1/f noise;,citation_abstract=We show that dynamical systems with spatial degrees of freedom naturally evolve into a self-organized critical point. Flicker noise, or 1/f noise, can be identified with the dynamics of the critical state. This picture also yields insight into the origin of fractal objects.;,citation_author=Per Bak;,citation_author=Chao Tang;,citation_author=Kurt Wiesenfeld;,citation_publication_date=1987-07-27;,citation_cover_date=1987-07-27;,citation_year=1987;,citation_fulltext_html_url=https://link.aps.org/doi/10.1103/PhysRevLett.59.381;,citation_issue=4;,citation_doi=10.1103/PhysRevLett.59.381;,citation_volume=59;,citation_journal_title=Physical Review Letters;,citation_journal_abbrev=Phys. Rev. Lett.;">
<meta name="citation_reference" content="citation_title=Self-organized criticality;,citation_abstract=We show that certain extended dissipative dynamical systems naturally evolve into a critical state, with no characteristic time or length scales. The temporal “‘fingerprint’” of the self-organized critical state is the presence of flicker noise or 1/f noise; its spatial signature is the emergence of scale-invariant (fractal) structure.;,citation_author=Per Bak;,citation_author=Chao Tang;,citation_author=Kurt Wiesenfeld;,citation_publication_date=1988-07-01;,citation_cover_date=1988-07-01;,citation_year=1988;,citation_fulltext_html_url=https://link.aps.org/doi/10.1103/PhysRevA.38.364;,citation_issue=1;,citation_doi=10.1103/PhysRevA.38.364;,citation_volume=38;,citation_journal_title=Physical Review A;,citation_journal_abbrev=Phys. Rev. A;">
<meta name="citation_reference" content="citation_title=Self-organized critical state of sandpile automaton models;,citation_abstract=We study a general Bak-Tang-Wiesenfeld–type automaton model of self-organized criticality in which the toppling conditions depend on local height, but not on its gradient. We characterize the critical state, and determine its entropy for an arbitrary finite lattice in any dimension. The two-point correlation function is shown to satisfy a linear equation. The spectrum of relaxation times describing the approach to the critical state is also determined exactly.;,citation_author=Deepak Dhar;,citation_publication_date=1990-04-02;,citation_cover_date=1990-04-02;,citation_year=1990;,citation_fulltext_html_url=https://link.aps.org/doi/10.1103/PhysRevLett.64.1613;,citation_issue=14;,citation_doi=10.1103/PhysRevLett.64.1613;,citation_volume=64;,citation_journal_title=Physical Review Letters;,citation_journal_abbrev=Phys. Rev. Lett.;">
</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">The Art of Scientific computation</h1>
            <p class="subtitle lead">A comparison of Python and Julia in the context of the Abelian Sandpile Model</p>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
            <div class="quarto-title-meta-author">
          <div class="quarto-title-meta-heading">Author</div>
          <div class="quarto-title-meta-heading">Affiliation</div>
          
                <div class="quarto-title-meta-contents">
            <p class="author">(James) Reuben Bender </p>
          </div>
                <div class="quarto-title-meta-contents">
                    <p class="affiliation">
                        The University of Melbourne
                      </p>
                  </div>
                    </div>
        
        <div class="quarto-title-meta">

                      
          
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      <div class="quarto-alternate-formats"><div class="quarto-title-meta-heading">Other Formats</div><div class="quarto-title-meta-contents"><p><a href="index.docx"><i class="bi bi-file-word"></i>MS Word</a></p></div><div class="quarto-title-meta-contents"><p><a href="index-meca.zip" data-meca-link="true"><i class="bi bi-archive"></i>MECA Bundle</a></p></div></div></div>
    </div>



    <div class="quarto-other-links-text-target">
    </div>  </div>
</header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#summary" id="toc-summary" class="nav-link active" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#background" id="toc-background" class="nav-link" data-scroll-target="#background">Background</a>
  <ul class="collapse">
  <li><a href="#sandpile-models" id="toc-sandpile-models" class="nav-link" data-scroll-target="#sandpile-models">Sandpile Models</a></li>
  <li><a href="#computational-simulation" id="toc-computational-simulation" class="nav-link" data-scroll-target="#computational-simulation">Computational simulation</a></li>
  </ul></li>
  <li><a href="#aims" id="toc-aims" class="nav-link" data-scroll-target="#aims">Aims</a></li>
  </ul></li>
  <li><a href="#methodology" id="toc-methodology" class="nav-link" data-scroll-target="#methodology">Methodology</a>
  <ul class="collapse">
  <li><a href="#simulation-algorithms" id="toc-simulation-algorithms" class="nav-link" data-scroll-target="#simulation-algorithms">Simulation Algorithms</a>
  <ul class="collapse">
  <li><a href="#toppling-algorithms" id="toc-toppling-algorithms" class="nav-link" data-scroll-target="#toppling-algorithms">Toppling Algorithms</a></li>
  <li><a href="#stabilisation-algorithms" id="toc-stabilisation-algorithms" class="nav-link" data-scroll-target="#stabilisation-algorithms">Stabilisation algorithms</a></li>
  <li><a href="#targeted-stabilisation-algorithm" id="toc-targeted-stabilisation-algorithm" class="nav-link" data-scroll-target="#targeted-stabilisation-algorithm">Targeted stabilisation algorithm</a></li>
  </ul></li>
  <li><a href="#implementation-details" id="toc-implementation-details" class="nav-link" data-scroll-target="#implementation-details">Implementation Details</a>
  <ul class="collapse">
  <li><a href="#python-implementation" id="toc-python-implementation" class="nav-link" data-scroll-target="#python-implementation">Python Implementation</a></li>
  </ul></li>
  <li><a href="#computational-environment" id="toc-computational-environment" class="nav-link" data-scroll-target="#computational-environment">Computational Environment</a></li>
  <li><a href="#performance-analysis" id="toc-performance-analysis" class="nav-link" data-scroll-target="#performance-analysis">Performance Analysis</a>
  <ul class="collapse">
  <li><a href="#different-toppling-algorithms" id="toc-different-toppling-algorithms" class="nav-link" data-scroll-target="#different-toppling-algorithms">Different Toppling Algorithms</a></li>
  </ul></li>
  <li><a href="#properties-of-the-sandpile" id="toc-properties-of-the-sandpile" class="nav-link" data-scroll-target="#properties-of-the-sandpile">Properties of the Sandpile</a></li>
  <li><a href="#comparison-of-results" id="toc-comparison-of-results" class="nav-link" data-scroll-target="#comparison-of-results">Comparison of Results</a></li>
  </ul></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a>
  <ul class="collapse">
  <li><a href="#abelian-model" id="toc-abelian-model" class="nav-link" data-scroll-target="#abelian-model">Abelian model</a></li>
  <li><a href="#language-comparison" id="toc-language-comparison" class="nav-link" data-scroll-target="#language-comparison">Language comparison</a>
  <ul class="collapse">
  <li><a href="#advantages-and-limitations" id="toc-advantages-and-limitations" class="nav-link" data-scroll-target="#advantages-and-limitations">Advantages and Limitations</a></li>
  </ul></li>
  <li><a href="#implications-for-computational-simulations" id="toc-implications-for-computational-simulations" class="nav-link" data-scroll-target="#implications-for-computational-simulations">Implications for Computational Simulations</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a>
  <ul class="collapse">
  <li><a href="#summary-of-findings" id="toc-summary-of-findings" class="nav-link" data-scroll-target="#summary-of-findings">Summary of Findings</a></li>
  <li><a href="#recommendations" id="toc-recommendations" class="nav-link" data-scroll-target="#recommendations">Recommendations</a></li>
  <li><a href="#future-work" id="toc-future-work" class="nav-link" data-scroll-target="#future-work">Future Work</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  <li><a href="#appendices" id="toc-appendices" class="nav-link" data-scroll-target="#appendices">Appendices</a></li>
  </ul>
<div class="quarto-alternate-notebooks"><h2>Notebooks</h2><ul><li><a href="Sections\Introduction-preview.html"><i class="bi bi-journal-code"></i>The abelian sandpile model</a></li></ul></div></nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



  


<section id="summary" class="level1">
<h1>Summary</h1>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<section id="sandpile-models" class="level3">
<h3 class="anchored" data-anchor-id="sandpile-models">Sandpile Models</h3>
<ul>
<li>Criticality</li>
<li>Self-organized criticality</li>
<li>Abelian sandpile model</li>
<li>Generalised toppling processes</li>
<li>Applications</li>
</ul>
</section>
<section id="computational-simulation" class="level3">
<h3 class="anchored" data-anchor-id="computational-simulation">Computational simulation</h3>
<ul>
<li>Importance</li>
<li>Challenges</li>
<li>Programming languages
<ul>
<li>Python</li>
<li>Julia</li>
</ul></li>
</ul>
</section>
</section>
<section id="aims" class="level2">
<h2 class="anchored" data-anchor-id="aims">Aims</h2>
<ul>
<li>Impliment the Abelian Sandpile Model in Python and Julia</li>
<li>Compare the performance of the two languages
<ul>
<li>Speed</li>
<li>Memory usage</li>
<li>Scalability</li>
<li>Numerical stability</li>
</ul></li>
</ul>
</section>
</section>
<section id="methodology" class="level1">
<h1>Methodology</h1>
<section id="simulation-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="simulation-algorithms">Simulation Algorithms</h2>
<section id="toppling-algorithms" class="level3">
<h3 class="anchored" data-anchor-id="toppling-algorithms">Toppling Algorithms</h3>
<section id="push-topple-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="push-topple-algorithm">‘Push’ topple algorithm</h4>
<p>The naive algorithm is naive in the sense that it is the most straightforward way to implement the toppling algorithm, but also in the sense that it does not assume any information about where topples might occur (i.e.&nbsp;it checks every site, c.f. the targeted algorithm). The algorithm iterates over each site in the lattice, and if the site has more sand than the threshold, it topples and sends sand to its neighbors.</p>
<div id="alg-push_topple" class="pseudocode-container quarto-float" data-comment-delimiter="//" data-line-number="true" data-pseudocode-number="1" data-no-end="false" data-caption-prefix="Algorithm" data-indent-size="1.2em" data-line-number-punc=":">
<div class="pseudocode">
\begin{algorithm} \caption{Push toppling algorithm} \begin{algorithmic} \input{a $n \times m$ lattice $X$, topple threshold $k$, a site $i$} \output{a $n \times m$ lattice $Y$} \If {$X_{i} \geq k$} \State $Y_{i} \gets X_{i} - k$ \For{each neighbor $j$ of $i$} \State $Y_j \gets X_j + 1$ \EndFor \Else \State $Y_i \gets X_i$ \EndIf \end{algorithmic} \end{algorithm}
</div>
</div>
<p>Because the every topple event using the naive algorithm effects the output of five locations on the lattice, the algorithm is not suitable for parallelization: the order of the for loop must be preserved to prevent multiple threads from updating the same site simultaneously (which would potentially lead to conflicting results when checking if a site is above the threshold). To remedy this limitation, we can use the parallel, or ‘pull’ algorithm</p>
</section>
<section id="pull-topple-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="pull-topple-algorithm">‘pull’ topple algorithm</h4>
<p>The parrallel is based on the idea of “pulling” sand from neighbors rather than “pushing” sand to neighbors. Each iteration of the for loop therefore only changes one site (i.e.&nbsp;each iteration is encapsulated), and therefore each cell can be updated in parallel.</p>
<div id="alg-pull_topple" class="pseudocode-container quarto-float" data-comment-delimiter="//" data-line-number="true" data-pseudocode-number="2" data-no-end="false" data-caption-prefix="Algorithm" data-indent-size="1.2em" data-line-number-punc=":">
<div class="pseudocode">
\begin{algorithm} \caption{Pull toppling algorithm} \begin{algorithmic} \input{ a $n \times m$ lattice $X$, topple threshold $k$, a site $i$} \output{a $n \times m$ lattice $Y$} \If {$X_i \geq k$} \State $Y_i$ $\gets$ $X_i - k$ \Else \State $Y_i$ $\gets$ $X_i$ \EndIf \For {each neighbor $j$ of $i$} \If {$X_j \geq k$} \State $Y_i$ $\gets$ $Y_i + 1$ \EndIf \EndFor \end{algorihmic} \end{algorithm}
</div>
</div>
</section>
</section>
<section id="stabilisation-algorithms" class="level3">
<h3 class="anchored" data-anchor-id="stabilisation-algorithms">Stabilisation algorithms</h3>
<section id="naive-stabilisation-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="naive-stabilisation-algorithm">Naive stabilisation algorithm</h4>
<p>The naive stabilisation algorithm is naive in the sense that it is the most straightforward way to implement the toppling algorithm, but also in the sense that it does not assume any information about where topples might occur. It iterates over each site in the lattice, and if the site has more sand than the threshold, it topples. This loop is repeated until each cell is below the toppling threshold. This algorithm works effectively with both push and pull toppling algorithms.</p>
<div id="alg-naive_stabilise" class="pseudocode-container quarto-float" data-comment-delimiter="//" data-line-number="true" data-pseudocode-number="3" data-no-end="false" data-caption-prefix="Algorithm" data-indent-size="1.2em" data-line-number-punc=":">
<div class="pseudocode">
\begin{algorithm} \caption{Naive stabilisation algorithm} \begin{algorithmic} \input{ a $n \times m$ lattice $X$, topple threshold $k$} \output{ $n \times m$ lattice $Y$} \While {any site in $X$ is above $k$} \For {each site $i$ in $X$} \If {$X_i \geq k$} \State $Y$ $\gets$ topple!(X, i) \Else \State $Y_i$ $\gets$ $X_i$ \EndIf \EndFor \EndWhile \end{algorihmic} \end{algorithm}
</div>
</div>
</section>
</section>
<section id="targeted-stabilisation-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="targeted-stabilisation-algorithm">Targeted stabilisation algorithm</h3>
<p>This algorithm assumes we have information about the locations of potential topple sites. For example, when dropping a single grain of sand, we first can check if the drop site needs to toppled. If it doesn’t, there is no possibility of avalance and no other sites need to be checked. If it does, can topple that site and just check the the neighbors to which the sand spreads. While needing less checks, we now must keep track of the sites that need to be checked. It is expected that this algorithm will provide performance improvements when the number of sites that need to be checked is significantly less than the total number of sites (i.e.&nbsp;a ‘sparse’ avalance)</p>
<div id="alg-targeted_topple" class="pseudocode-container quarto-float" data-comment-delimiter="//" data-line-number="true" data-pseudocode-number="4" data-no-end="false" data-caption-prefix="Algorithm" data-indent-size="1.2em" data-line-number-punc=":">
<div class="pseudocode">
\begin{algorithm} \caption{Targeted toppling algorithm} \begin{algorithmic} \input{ a $n \times m$ lattice $X$, topple threshold $k$, A list of sites to check $L$} \output{ sandpile model lattice $Y$} \While {$L$ is not empty} \State remove element $i$ from $L$ \If {$X_i \leq k$} \State $Y \gets$ topple!(X, i) \EndIf \EndWhile \end{algorihmic} \end{algorithm}
</div>
</div>
</section>
</section>
<section id="implementation-details" class="level2">
<h2 class="anchored" data-anchor-id="implementation-details">Implementation Details</h2>
<section id="python-implementation" class="level3">
<h3 class="anchored" data-anchor-id="python-implementation">Python Implementation</h3>
<ul>
<li><p>naive</p></li>
<li><p>parallel</p></li>
<li><p>optimised</p></li>
<li><p>total ### Julia Implementation</p></li>
<li><p>naive</p></li>
<li><p>parallel</p></li>
<li><p>optimised</p></li>
<li><p>total</p></li>
</ul>
</section>
</section>
<section id="computational-environment" class="level2">
<h2 class="anchored" data-anchor-id="computational-environment">Computational Environment</h2>
<ul>
<li><p>Hardware</p></li>
<li><p>Software</p></li>
<li><p>Libraries ## Performance Metrics</p></li>
<li><p>Execution time</p></li>
<li><p>Memory consumption</p></li>
<li><p>Scalability</p></li>
<li><p>Numerical stability # Results</p></li>
</ul>
</section>
<section id="performance-analysis" class="level2">
<h2 class="anchored" data-anchor-id="performance-analysis">Performance Analysis</h2>
<section id="different-toppling-algorithms" class="level3">
<h3 class="anchored" data-anchor-id="different-toppling-algorithms">Different Toppling Algorithms</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="figures/topple_algos_benchmark.png" class="lightbox" data-glightbox="description: .lightbox-desc-1" data-gallery="quarto-lightbox-gallery-1" title="Execution time for different toppling algorithms"><img src="figures/topple_algos_benchmark.png" class="img-fluid figure-img" alt="Execution time for different toppling algorithms"></a></p>
<figcaption>Execution time for different toppling algorithms</figcaption>
</figure>
</div>
</section>
</section>
<section id="properties-of-the-sandpile" class="level2">
<h2 class="anchored" data-anchor-id="properties-of-the-sandpile">Properties of the Sandpile</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="figures/topple_freqs.png" class="lightbox" data-glightbox="description: .lightbox-desc-2" data-gallery="quarto-lightbox-gallery-2" title="Distribution of avalanche sizes in the abelian sandpile model at different grid sizes"><img src="figures/topple_freqs.png" class="img-fluid figure-img" alt="Distribution of avalanche sizes in the abelian sandpile model at different grid sizes"></a></p>
<figcaption>Distribution of avalanche sizes in the abelian sandpile model at different grid sizes</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="figures/slope_vs_size.png" class="lightbox" data-glightbox="description: .lightbox-desc-3" data-gallery="quarto-lightbox-gallery-3" title="OLS coefficients for topple size and frequency bu lattice size"><img src="figures/slope_vs_size.png" class="img-fluid figure-img" alt="OLS coefficients for topple size and frequency bu lattice size"></a></p>
<figcaption>OLS coefficients for topple size and frequency bu lattice size</figcaption>
</figure>
</div>
</section>
<section id="comparison-of-results" class="level2">
<h2 class="anchored" data-anchor-id="comparison-of-results">Comparison of Results</h2>
</section>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<section id="abelian-model" class="level2">
<h2 class="anchored" data-anchor-id="abelian-model">Abelian model</h2>
</section>
<section id="language-comparison" class="level2">
<h2 class="anchored" data-anchor-id="language-comparison">Language comparison</h2>
<section id="advantages-and-limitations" class="level3">
<h3 class="anchored" data-anchor-id="advantages-and-limitations">Advantages and Limitations</h3>
</section>
</section>
<section id="implications-for-computational-simulations" class="level2">
<h2 class="anchored" data-anchor-id="implications-for-computational-simulations">Implications for Computational Simulations</h2>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<section id="summary-of-findings" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-findings">Summary of Findings</h2>
</section>
<section id="recommendations" class="level2">
<h2 class="anchored" data-anchor-id="recommendations">Recommendations</h2>
</section>
<section id="future-work" class="level2">
<h2 class="anchored" data-anchor-id="future-work">Future Work</h2>
</section>
</section>
<section id="references" class="level1">
<h1>References</h1>
</section>
<section id="appendices" class="level1">
<h1>Appendices</h1>
<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-1">Execution time for different toppling algorithms</span>
<span class="glightbox-desc lightbox-desc-2">Distribution of avalanche sizes in the abelian sandpile model at different grid sizes</span>
<span class="glightbox-desc lightbox-desc-3">OLS coefficients for topple size and frequency bu lattice size</span>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
    <script type="text/javascript">
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let pseudocodeOptions = {
          indentSize: el.dataset.indentSize || "1.2em",
          commentDelimiter: el.dataset.commentDelimiter || "//",
          lineNumber: el.dataset.lineNumber === "true" ? true : false,
          lineNumberPunc: el.dataset.lineNumberPunc || ":",
          noEnd: el.dataset.noEnd === "true" ? true : false,
          titlePrefix: el.dataset.captionPrefix || "Algorithm"
        };
        pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
      });
    })(document);
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let captionSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
        if (captionSpan !== null) {
          let captionPrefix = el.dataset.captionPrefix + " ";
          let captionNumber = "";
          if (el.dataset.pseudocodeNumber) {
            captionNumber = el.dataset.pseudocodeNumber + " ";
            if (el.dataset.chapterLevel) {
              captionNumber = el.dataset.chapterLevel + "." + captionNumber;
            }
          }
          captionSpan.innerHTML = captionPrefix + captionNumber;
        }
      });
    })(document);
    </script>
  
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","selector":".lightbox","loop":false,"openEffect":"zoom","descPosition":"bottom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>