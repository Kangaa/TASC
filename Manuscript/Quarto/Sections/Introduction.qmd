## The abelian sandpile model
The abelian sandpile model is a cellular automaton that models the behavior of a pile of sand grains. The model is defined on a lattice, where each point (site) can hold a certain number of grains (i.e. be at a certain 'height'). When a site reaches a certain height, it becomes unstable and topples, sending one grain to each of its neighbors. This spread of sand can cause a chain reaction of topplings -an avalanche- that can propagate through the lattice. While each topple is simple and deterministic, predicting the size and shape of the avalanches on a large lattice can be non-trivial - a problem compounded as we model the behaviour of the system over time (i.e. as we continue to add grains). Therefore, the abelian sandpile model is a good candidate for computational simulation. By repeating the toppling/avalance process iteratively, we can might hope to characterise statistical features of the system, such as the distribution of avalanche sizes (both in terms of number of topples and spatial scale), the average number of grains present on the lattice, or the 

When implimenting a sumultation of the ASM, we do not have the option of employing an infinite sized grid. Instead, we must choose a finite grid size, and implement special transition conditions at the boundaries. 

When using a finite grid and losing grains at the edges, our output is subject to so called 'finite size effects', whereby extreme events are less common than we would expect on an infinite grid. This is because the avalanches are more likely to be cut off by the boundaries. 
To a
### Applications of the BTW model
    e.g. simulation of physical systems, traffic flow, forest fires, epidemiological models etc.
## Scientific programming tools

In large sandpiles, which have the potential for large scale avalanves (e.g. involving millions of topples), the computational tools and techniques used to simulate the model are crucial. A secomdary aim of this progject (in adittion to presenting the BTW model) is to explore several alternative computational techniques for developing and simulating the model. There are two main aspects I will consider:

Algorithm design: The way in which the toppling and stabilisation algorithms implemented can have a significant impact on the efficiency of the simulation. These design decisions will depend on the backend on which the simulation is run - e.g. Does the algorithm complexity scale efficiently with the lattice size (to avoid memory bottlenecks)? Can the algorithm make use of the multithreading capabilities of modern CPUs (or, moreover, GPUs)?  Therefore, there is unlikely to be a single optimal algorithm, but rather a trade-off between different factors. I will compare the performance of several different algorithms for simulating the BTW model.

Programming languages: The choice of programming language can also have a significant impact on the efficiency of simulation; both in the sense  of the time taken to run the simulation, and the ease of developing and maintaining code. Modern scientific programming typically falls into a two-language paridigm, wherein a relatively high-level, dynamic language (usually python) is used for rapid prototyping and data analysis, and a lower-level, statically typed and compiled language (e.g. C, C++, Fortran) is used for computationally intensive tasks. There is some middle ground here with the use of high level wrappers in dynamic languages that call high performance compiled code for performance critical tasks (e.g. numpy, scipy, numba in python).

While these approaches well established and can result in highly efficient implimentations, the two language approach has drawbacks. The most obvious is the need to develop (and potentially maintain) two separate codebases. Moreover, the specialised skills needed to develop and maintain high performance code in a low-level language can be a barrier to entry for many researchers. This barrier can be compounded by the discontinuity in source material between two codebases. For example, localising and adressing bugs can require more elaborate error handling and logging when the code is split between two languages.

The Julia language